enum tipka
{
    reset,
    start_stop
}; // poimenovanje tipk VREDNOSTI imen{0,1}
tipka iTip;

const byte vhod_n = 2;                 // stev vhodov
const byte tip_pin[vhod_n] = {18, 19}; // A4, A5
bool vhodSt_0[] = {0, 0};              // predhodno stanje vhoda
bool vhodSt_x[] = {1, 1};              // trenutno stanje vhoda
bool vhodReg[] = {1, 1};               // zabelezeno stanje tipke
bool deluje = false;                   // stanje Å¡tevca (deluje/ne deluje)
unsigned long tx_cas = 0;              // tx- trenutni cas
unsigned long t0_cas = 0;              // to - predhodni cas
int td = 5;                            // td - zakasnitev tipke 5-50 ms
unsigned long ttx[vhod_n] = {0, 0};    // ttx- trenutni cas tipke
unsigned long tt0[vhod_n] = {0, 0};    // tte - prethodni cas tipke
byte sec = 0;
byte min = 0;

// segmenti  a  b  c  d  e  f  g
byte n[11][7] = {
    {1, 1, 1, 1, 1, 1, 0},
    {0, 1, 1, 0, 0, 0, 0},
    {1, 1, 0, 1, 1, 0, 1},
    {1, 1, 1, 1, 0, 0, 1},
    {0, 1, 1, 0, 0, 1, 1},
    {1, 0, 1, 1, 0, 1, 1},
    {1, 0, 1, 1, 1, 1, 1},
    {1, 1, 1, 0, 0, 0, 0},
    {1, 1, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 0, 1, 1},
    {0, 0, 0, 0, 0, 0, 0} // ugasne vse segmenete
};

byte dp = 9;

void setup()
{
    for (byte pin = 2; pin <= 13; pin++)
    {
        pinMode(pin, OUTPUT);
    }
    pinMode(18, INPUT_PULLUP);
    pinMode(19, INPUT_PULLUP);
    Serial.begin(9600);
    vhodSt_x[0] = reset;
}
void stevec();
void prikaz();
void scanVhod();
void setOutReg();
void printTab(bool tab[vhod_n], String imeTab); // prototip - za delovanje

void loop()
{
    tx_cas = millis();
    scanVhod();
    setOutReg();
    if (deluje == true)
    {
        stevec();
        prikaz();
    }
    else
        prikaz();
}

void mux(byte modul)
{
    byte liveLED[][4] = {
        {1, 0, 0, 0},
        {0, 1, 0, 0},
        {0, 0, 1, 0},
        {0, 0, 0, 1},
        {0, 0, 0, 0},
    };
    if (modul == 2)
        digitalWrite(dp, 1);
    else
        digitalWrite(dp, 0);
    for (byte i = 0; i < 4; i++)
    {
        digitalWrite(i + 10, liveLED[modul][i]);
    }
    delay(1);
}
void stevka(byte st)
{
    for (byte i = 0; i < 7; i++)
    {
        digitalWrite(i + 2, n[st][i]);
        digitalWrite(dp, 0); // ugasne piko
    }
}
void stevec()
{
    if ((tx_cas - t0_cas) >= 100)
    {
        sec++;
        if (sec >= 60)
        {
            min++;
            sec = 0;
        }
        if (min >= 100)
        {
            min = 0;
        }
        t0_cas = tx_cas;
    }
    Serial.print(min);
    Serial.print(":");
    Serial.println(sec);
}
void prikaz()
{
    stevka(10);
    mux(4); // stevka(10) == ponastavitev
    stevka(sec % 10);
    mux(0);

    stevka(10);
    mux(4);
    stevka(sec / 10);
    mux(1);

    stevka(10);
    mux(4);
    stevka(min % 10);
    mux(2);

    stevka(10);
    mux(4);
    stevka(min / 10);
    mux(3);

    stevka(10);
    mux(4);
}

void scanVhod()
{ // pregleda vhode z tipkami s 5-50 ms zakasnitve
    for (int i = 0; i < vhod_n; i++)
    {
        bool readTip = digitalRead(tip_pin[i]); // beremo stanje vhoda

        // razlika med trenutno in predhodnim stanjem!!
        if (readTip != vhodSt_0[i])
        {
            // predhodni cas tipke = trenutni cas
            tt0[i] = tx_cas;
        }
        // zacetni cas pri pritisku tipke if((tx_castte[i]) > td) {
        if ((tx_cas - tt0[i]) > td)
        {
            if (readTip != vhodSt_x[i])
            {
                vhodSt_x[i] = readTip; // zapisemo spremembo stanja vhoda po 5ms
                if (vhodSt_x[i] == HIGH)
                {
                    vhodReg[i] = HIGH; // zapis v registar stanja tipk
                }
            }
        }
        vhodSt_0[i] = readTip;
    }
}
void setOutReg()
{ // funkcija naredi akcije glede na stanje registra
    for (int i = 0; i < vhod_n; i++)
    {
        if (vhodReg[i] == HIGH)
        {
            switch (i)
            {
            case reset:
                sec = 0;
                min = 0;
                deluje = false;
                break;
            case start_stop:
                deluje = !deluje;
                break;
            }
            printTab(vhodReg, "vhod");
            vhodReg[i] = LOW;
        }
    }
}
void printTab(bool tab[vhod_n], String imeTab)
{
    Serial.println(imeTab);
    for (int i = 0; i < vhod_n; i++)
    {

        Serial.print(tab[i]);
        Serial.print(", ");
        switch (i)
        {
        case reset:
            Serial.println("tipka reset");
            break;
        case start_stop:
            Serial.println("tipka start_stop ");
            break;
        }
    }
    Serial.println();
}